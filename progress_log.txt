=== TopFusen 実装進捗ログ ===

--- 2026-02-06 Phase 0: プロジェクト基盤 ---

[完了] P0-1: .NET 8 WPF ソリューション作成
  - dotnet new wpf -n TopFusen で WPF プロジェクト生成
  - dotnet new sln で TopFusen.sln 作成
  - フォルダ構成: Models/, Views/, ViewModels/, Services/, Interop/, Assets/
  - TargetFramework: net8.0-windows10.0.17763.0

[完了] P0-2: app.manifest
  - PerMonitorV2 DPI Awareness 宣言
  - UAC = asInvoker（管理者権限不要）
  - Windows 10/11 互換性宣言

[完了] P0-3: App.xaml — ShutdownMode=OnExplicitShutdown

[完了] P0-4: DI コンテナ
  - Microsoft.Extensions.DependencyInjection 8.0.1
  - Microsoft.Extensions.Hosting 8.0.1
  - App.xaml.cs の ConfigureServices で登録

[完了] P0-5: Serilog ログ基盤
  - Serilog 4.2.0 + Serilog.Sinks.File 6.0.0 + Serilog.Extensions.Hosting 8.0.0
  - 出力先: %LocalAppData%\TopFusen\TopFusen\logs\app_yyyyMMdd.log
  - ローテーション: 7日分保持
  - 起動時に全7行のログ出力を確認済み

[完了] P0-6: モデル定義
  - NoteModel.cs: NoteId(GUID), MonitorIdentity, NotePlacement(DJ-3準拠), NoteStyle
  - AppSettings.cs: IsHidden, HotkeySettings, FontAllowList, ZOrderByDesktop
  - NotesData.cs: notes.json のルートオブジェクト

[完了] P0-7: .gitignore（dotnet + VS + Rider テンプレート）

[完了] P0-8: README.md（プロジェクト概要 + ビルド手順 + 構成図）

[完了] P0-9: 単一インスタンス制御
  - SingleInstanceService.cs: Mutex + NamedPipe IPC
  - 二重起動テスト: 2番目のプロセスが即終了 + IPC コマンド送受信成功

[完了] P0-10: トレイ実装方式確定
  - H.NotifyIcon.Wpf 2.1.3 を採用（net8.0-windows10.0.17763 互換）
  - 2.4.1 は NU1701 警告が出るため 2.1.3 を採用

[検証] P0-VERIFY: 全項目合格
  ✅ ビルド成功（エラー0、警告0）
  ✅ アプリ起動 → ShutdownMode=OnExplicitShutdown で常駐
  ✅ ログファイル生成確認（app_20260206.log）
  ✅ 二重起動テスト成功（Mutex排他 + IPC通信）

--- 2026-02-06 Phase 1: タスクトレイ常駐 + 最小付箋表示 ---

[完了] P1-1: タスクトレイアイコン実装
  - Assets/app.ico を PowerShell + System.Drawing で生成（32x32 付箋風アイコン）
  - TopFusen.csproj に ApplicationIcon + Resource 設定
  - H.NotifyIcon.Wpf 2.1.3 の TaskbarIcon クラスで表示
  - IconSource = pack://application:,,,/Assets/app.ico

[完了] P1-2: トレイ右クリックメニュー骨格
  - App.xaml.cs の CreateTrayContextMenu() で ContextMenu 構築
  - 編集モード ON/OFF（トグル）— Phase 2 でクリック透過と連動予定
  - 新規付箋作成 — NoteManager.CreateNote() 呼び出し
  - 一時的に非表示（stub: Phase 10）
  - 設定を開く（stub: Phase 11）
  - 終了 — Application.Current.Shutdown() → OnExit でクリーンアップ

[完了] P1-3: NoteWindow 基本実装
  - Views/NoteWindow.xaml: WindowStyle=None, AllowsTransparency=True, Topmost=True
  - ShowInTaskbar=False, MinWidth=160, MinHeight=120
  - Border 背景色 #FFFBE38C（付箋風の黄色）
  - TextBlock をプレースホルダ配置（Phase 4 で RichTextBox に置き換え）

[完了] P1-4: NoteManager 骨格
  - Services/NoteManager.cs: CreateNote() / DeleteNote() / CloseAllWindows()
  - プライマリモニタ WorkArea 中央に配置
  - DI コンテナに Singleton 登録

[完了] P1-5: NoteWindow を Alt+Tab / タスクバーから隠す
  - Interop/NativeMethods.cs: GetWindowLong / SetWindowLong の P/Invoke
  - NoteWindow.OnSourceInitialized で WS_EX_TOOLWINDOW 付与 + WS_EX_APPWINDOW 除去

[検証] P1-VERIFY: 検証完了
  ✅ ビルド成功（エラー0、警告0）
  ✅ トレイアイコン表示（ログ: 「トレイアイコンを初期化しました」）
  ✅ 右クリックメニュー表示
  ✅ 新規付箋作成で NoteWindow 表示
  ✅ 終了でプロセス完全終了
  ✅ 付箋が Topmost
  ✅ Alt+Tab に付箋が出ない（WS_EX_TOOLWINDOW）
  ✅ タスクバーに付箋が出ない（ShowInTaskbar=False）

新規ファイル:
  - TopFusen/Assets/app.ico（トレイアイコン）
  - TopFusen/Interop/NativeMethods.cs（Win32 P/Invoke）
  - TopFusen/Views/NoteWindow.xaml（付箋ウィンドウ XAML）
  - TopFusen/Views/NoteWindow.xaml.cs（付箋ウィンドウ コードビハインド）
  - TopFusen/Services/NoteManager.cs（付箋ライフサイクル管理）

変更ファイル:
  - TopFusen/App.xaml.cs（トレイ初期化 + メニュー + NoteManager 統合）
  - TopFusen/TopFusen.csproj（ApplicationIcon + Resource 追加）

NuGet パッケージ一覧:
  - Microsoft.Extensions.DependencyInjection 8.0.1
  - Microsoft.Extensions.Hosting 8.0.1
  - Serilog 4.2.0
  - Serilog.Sinks.File 6.0.0
  - Serilog.Extensions.Hosting 8.0.0
  - H.NotifyIcon.Wpf 2.1.3

--- 2026-02-06 Phase 2: Win32 Interop + モード切替 ---

[完了] P2-1: Win32 Interop ヘルパー拡張
  - NativeMethods.cs に定数追加:
    WS_EX_TRANSPARENT (0x00000020), WS_EX_LAYERED (0x00080000), WS_EX_NOACTIVATE (0x08000000)

[完了] P2-2: NoteWindow にクリック透過の ON/OFF 実装（三重制御方式）
  - SetClickThrough(bool) メソッド追加
  - 制御方式:
    1. WS_EX_TRANSPARENT: Win32 レベルのクリック透過
    2. WS_EX_NOACTIVATE: フォーカスを奪わない
    3. WM_NCHITTEST フック: HTTRANSPARENT を返してメッセージレベルで透過
  - ★重要知見: WPF AllowsTransparency=True（WS_EX_LAYERED）環境では
    WS_EX_TRANSPARENT の ON/OFF だけではクリック透過の切替が不十分。
    WM_NCHITTEST で HTTRANSPARENT を返す方式を併用する三重制御が必要。
  - NoteWindow コンストラクタに clickThrough パラメータ追加（初期状態制御）

[完了] P2-3: AppHost にモード管理
  - NoteManager に IsEditMode プロパティ + SetEditMode(bool) メソッド追加
  - SetEditMode で全 NoteWindow に一括で SetClickThrough を適用
  - CreateNote 時に現在の IsEditMode に基づいて初期 clickThrough 状態を設定
  - App.xaml.cs: _isEditMode を削除 → NoteManager.IsEditMode に一元化
  - トレイメニュー「編集モード」トグルが NoteManager.SetEditMode() と連動

[検証] P2-VERIFY: 全項目合格（★最重要技術検証クリア）
  ✅ ビルド成功（エラー0、警告0）
  ✅ 非干渉モード: 付箋上クリックで背後アプリが反応する
  ✅ 非干渉モード: 付箋がフォーカスを奪わない
  ✅ 編集モード: 付箋をクリックで選択・操作できる
  ✅ 編集モード: 付箋以外をクリックしても編集OFFに戻らない
  ✅ トレイメニューで ON/OFF が正しくトグルする
  ✅ TopMost が維持されている（他ウィンドウで隠れない）
  ✅ AllowsTransparency=True の状態で上記すべてが成立する
  ✅ Alt+Tab / タスクバーに付箋が出ない状態が維持されている

変更ファイル:
  - TopFusen/Interop/NativeMethods.cs（定数追加: WS_EX_TRANSPARENT, WS_EX_LAYERED, WS_EX_NOACTIVATE）
  - TopFusen/Views/NoteWindow.xaml.cs（SetClickThrough + WM_NCHITTEST フック追加）
  - TopFusen/Services/NoteManager.cs（IsEditMode + SetEditMode 追加）
  - TopFusen/App.xaml.cs（トレイメニュー連動更新）

設計判断追加:
  - DJ-6: クリック透過は三重制御方式を採用（WS_EX_TRANSPARENT + WS_EX_NOACTIVATE + WM_NCHITTEST）
    WPF AllowsTransparency=True 環境での確実な動作を保証するため

--- 2026-02-07 Phase 3: 付箋の移動・リサイズ + 基本UI ---

実装方針: 案B（WindowChrome + DragMove + 部分バインディング）

[完了] P3-1: WindowChrome 導入
  - ResizeBorderThickness=6（リサイズハンドル幅）
  - CaptionHeight=0（カスタムドラッグ領域）
  - GlassFrameThickness=0（AllowsTransparency=True 環境向け）
  - ★注意: UseAeroPeek は .NET 8 WPF の WindowChrome に存在しないため除外

[完了] P3-2: ドラッグ移動実装
  - ツールバー領域（上部 Border）の MouseLeftButtonDown → DragMove()
  - ドラッグハンドル「⠿」マーク + Cursor=SizeAll
  - ★WM_NCHITTEST フックとの共存: 編集モード時は IntPtr.Zero を返すので
    WPF のデフォルト処理に委譲 → WindowChrome のリサイズ判定が正常動作

[完了] P3-3: リサイズ実装
  - WindowChrome の ResizeBorderThickness=6 で角/辺リサイズを自然に実現
  - MinWidth=160, MinHeight=120 は XAML で制約済み（Phase 1 から）
  - AllowsTransparency + WindowChrome の組み合わせで問題なく動作を確認

[完了] P3-4: 選択状態管理
  - NoteWindow に IsSelected / IsInEditMode プロパティ追加
  - SetSelected() / SetInEditMode() メソッドで状態変更
  - UpdateVisualState() で UI 表示制御:
    - 編集ON + 選択中: ツールバー + 下部アイコン + 枠(BorderBrush) + 影(DropShadowEffect)
    - それ以外: 本文のみ（枠=Transparent, 影=null, UI=Collapsed）
  - NoteWindow.OnActivated → NoteActivated イベント → NoteManager.SelectNote() で選択連携
  - 編集OFF → DeselectAll() で選択クリア
  - NoteBorder.BorderThickness は常に 2（レイアウトシフト防止）、色の切替で表示制御

[完了] P3-5: 削除ボタン
  - 下部アイコン列に 🗑 ボタン配置
  - DeleteButton_Click → DeleteRequested イベント → NoteManager.DeleteNote()
  - イベント購読解除（UnwireNoteEvents）も確実に実行

[完了] P3-6: 複製ボタン
  - 下部アイコン列に 📋 ボタン配置
  - DuplicateButton_Click → DuplicateRequested イベント → NoteManager.DuplicateNote()
  - +24px ずらし + スタイル（色/不透明度/フォント）コピー + WorkArea クランプ
  - 複製後に新しい付箋を自動選択

[完了] P3-7: 編集OFF時の全UI非表示
  - SetEditMode(false) → 全 NoteWindow に SetInEditMode(false) + DeselectAll()
  - UpdateVisualState() で ToolbarArea / BottomBar を Collapsed, 枠/影を解除

追加実装:
  - 新規作成時の重なり検知 + ずらし（ApplyOverlapOffset: +24px、最大10回、クランプ付き）
  - NoteManager にイベント連携パターン（WireUpNoteEvents / UnwireNoteEvents）
  - ClampToWorkArea ヘルパー（WorkArea 内への位置補正）

[検証] P3-VERIFY: 全項目合格（ユーザー実機確認済み）
  ✅ ドラッグで付箋を移動できる
  ✅ 角/辺ドラッグでリサイズできる
  ✅ 最小サイズ（160×120）以下にならない
  ✅ 選択中の付箋だけツールバー/アイコン/枠が表示される
  ✅ 未選択付箋は本文のみ
  ✅ 削除ボタンで付箋が消える
  ✅ 複製ボタンで +24px ずれた付箋が生成される
  ✅ 編集OFF時にすべてのUI要素が消える
  ✅ AllowsTransparency + WindowChrome でリサイズが正常に動作する
  ✅ クリック透過（非干渉モード）が引き続き正常
  ✅ Alt+Tab / タスクバーに付箋が出ない

変更ファイル:
  - TopFusen/Views/NoteWindow.xaml（WindowChrome + Grid 3行レイアウト + ツールバー + 下部アイコン）
  - TopFusen/Views/NoteWindow.xaml.cs（選択状態管理 + DragMove + イベント + UpdateVisualState）
  - TopFusen/Services/NoteManager.cs（選択管理 + 複製 + イベント連携 + 重なり検知）

--- 2026-02-07 Phase 3.5: 仮想デスクトップ 技術スパイク ---

実装方針: 案B（全API検証 + VirtualDesktopService分離 + トレイ検証メニュー）

[完了] P3.5-1: COM Interop — IVirtualDesktopManager の初期化成立確認
  - Interop/VirtualDesktopInterop.cs: COM インターフェース定義
    - IVirtualDesktopManager（GUID: a5cd92ff-29be-454c-8d04-d82879fb3f1b）
    - CLSID_VirtualDesktopManager（aa509086-5ca9-4c25-8f95-589d3c07b48a）
    - メソッド: IsWindowOnCurrentVirtualDesktop, GetWindowDesktopId, MoveWindowToDesktop
  - Services/VirtualDesktopService.cs: Initialize() で CoCreateInstance
  - 結果: ✅ COM 初期化成功。IsAvailable=true
  - graceful 無効化: try/catch で COMException を捕捉、IsAvailable=false に設定

[完了] P3.5-2: 現在デスクトップID取得（短命ウィンドウ方式）
  - 短命 Window（Width=1, Height=1, Opacity=0, Left=-32000）を作成
  - GetWindowDesktopId で GUID 取得 → Window.Close()
  - 結果: ✅ 正しいデスクトップ GUID が取得できた
  - 注意: ShowActivated=false で他ウィンドウのフォーカスを奪わない

[完了] P3.5-3: MoveWindowToDesktop テスト
  - 普通の Window（WindowStyle=ToolWindow, ShowInTaskbar=true, Topmost=false）:
    ✅ MoveWindowToDesktop 成功。DesktopId が正しく変更される
  - NoteWindow（WS_EX_TOOLWINDOW + TOPMOST + LAYERED + TRANSPARENT + NOACTIVATE）:
    ❌ MoveWindowToDesktop は HRESULT=0（成功）を返すが、実際には移動しない
    ❌ GetWindowDesktopId が Guid.Empty を返す（OS がウィンドウを追跡していない）
  - ★★★ 根本原因判明（DJ-7）: WS_EX_TOOLWINDOW（オーナーなし）のウィンドウは
    仮想デスクトップ管理の対象外。OS がデスクトップ所属を追跡しない。
  - 追加テスト:
    - Topmost=false にしても変化なし
    - WS_EX_TOOLWINDOW を外しても変化なし（一度追跡外れたら復帰しない）
    - WS_EX_TRANSPARENT/NOACTIVATE を外しても変化なし
    - Hide → Move → Show でも変化なし
  - Phase 8 の対策: オーナーウィンドウ方式に変更
    - 非表示オーナー Window を作成し、NoteWindow.Owner に設定
    - オーナー付きウィンドウは Alt+Tab に出ない（WS_EX_TOOLWINDOW 不要）
    - かつ仮想デスクトップ管理に正常参加できる

[完了] P3.5-4: Registry からデスクトップ一覧取得
  - パス: HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\VirtualDesktops
  - VirtualDesktopIDs（REG_BINARY）→ 16bytes ごとに GUID パース → ✅ 成功
  - デスクトップ名: Desktops\{guid}\Name → ✅ 取得成功
  - 2デスクトップ環境で正常動作を確認

[検証] P3.5-VERIFY: スパイク検証結果
  ✅ COM 初期化が成功する
  ✅ 現在デスクトップ ID が GUID として取得できる
  ⚠️ NoteWindow の仮想デスクトップ移動: WS_EX_TOOLWINDOW が原因で不可（DJ-7）
    → Phase 8 でオーナーウィンドウ方式に変更して解決予定
  ✅ COM 失敗時にアプリがクラッシュしない（graceful 無効化）
  ✅ Registry からデスクトップ一覧が正しく取得できる

追加知見:
  - H.NotifyIcon.Wpf のトレイメニューから MessageBox を出すと一瞬で消える問題
    → async + await Task.Delay(300) でメニュー閉じ待ちが必要

設計判断追加:
  - DJ-7: WS_EX_TOOLWINDOW は仮想デスクトップ管理の対象外
    Phase 8 でオーナーウィンドウ方式に変更する

新規ファイル:
  - TopFusen/Interop/VirtualDesktopInterop.cs（COM インターフェース定義）
  - TopFusen/Services/VirtualDesktopService.cs（仮想デスクトップ操作サービス）

変更ファイル:
  - TopFusen/App.xaml.cs（VD サービス初期化 + スパイク検証メニュー追加）

--- 2026-02-07 Phase 3.7: DJ-7 対応 — WS_EX_TOOLWINDOW → オーナーウィンドウ方式 ---

背景: Phase 3.5 スパイクで WS_EX_TOOLWINDOW ウィンドウは仮想デスクトップ管理に参加しないことが判明（DJ-7）。
Phase 4〜7 の大量改修前に基盤変更を確定させるため、前倒しで実施。

[完了] P3.7-1: NoteManager にオーナーウィンドウ生成・管理を追加
  - 非表示 Window（Width=0, Height=0, Visibility=Hidden, AllowsTransparency=True）
  - WindowInteropHelper.EnsureHandle() で Show せずに HWND を確保
  - NoteWindow 作成時（CreateNote / DuplicateNote）に window.Owner = _ownerWindow を設定
  - CloseAllWindows: Owner 解除 → 子ウィンドウ Close → オーナー Close の順序で安全に終了
  - App.xaml.cs の OnStartup で _noteManager.InitializeOwnerWindow() を呼び出し

[完了] P3.7-2: NoteWindow から WS_EX_TOOLWINDOW を除去
  - OnSourceInitialized から WS_EX_TOOLWINDOW 付与 + WS_EX_APPWINDOW 除去を削除
  - 代わりに WS_EX_TOOLWINDOW が付いていたら外す処理に変更（念のため）
  - Owner + ShowInTaskbar=false で Alt+Tab 非表示が成立
  - クリック透過（三重制御: WS_EX_TRANSPARENT + WS_EX_NOACTIVATE + WM_NCHITTEST）はそのまま維持

[検証] P3.7-VERIFY: 全項目合格（★実機確認済み）
  ✅ ビルド成功（エラー0、警告0）
  ✅ Alt+Tab に付箋が出ない
  ✅ タスクバーに付箋が出ない
  ✅ GetWindowDesktopId が有効な GUID を返す（ExStyle=0x00080108, TOOLWINDOW=False）
  ✅ MoveWindowToDesktop で実際に付箋が別デスクトップへ移動する（テスト 1A: そのまま Move で成功）
  ✅ クリック透過（三重制御）が引き続き正常
  ✅ Topmost が維持されている（TOPMOST=True 確認済み）
  ✅ AllowsTransparency + Owner の組み合わせで問題なし
  ✅ ドラッグ移動・リサイズが正常
  ✅ 複数付箋の選択状態管理が正常

変更ファイル:
  - TopFusen/Services/NoteManager.cs（オーナーウィンドウ生成・管理 + Owner 設定）
  - TopFusen/Views/NoteWindow.xaml.cs（WS_EX_TOOLWINDOW 除去 + コメント更新）
  - TopFusen/App.xaml.cs（InitializeOwnerWindow 呼び出し追加）

設計判断追加:
  - DJ-8: WS_EX_TRANSPARENT/NOACTIVATE も生成時に付けると仮想デスクトップ追跡外
    - 追加テストで発見: 編集OFF（TRANSPARENT+NOACTIVATE付き）で作成した付箋は MoveWindowToDesktop が効かない
    - 後から外しても手遅れ（OS が生成時にウィンドウの追跡可否を決定する）
    - 対策: NoteWindow を常に「クリーン」で生成 → Show() 後に SetClickThrough() で適用
    - NoteWindow のコンストラクタでも IsInEditMode=false 固定（安全な初期状態）
    - Show() 後に NoteManager が SetInEditMode() / SetClickThrough() で実際の状態を適用
    - これにより Phase 8 の MoveWindowToDesktop は Show() と SetClickThrough() の間に挿入可能
  - ★実機検証: 編集ON/OFF どちらで作成しても VD移動成功 + UI表示も正常を確認済み

==============================
Phase 4: リッチテキスト編集（FR-TEXT）— 2026-02-07
==============================

[P4-1] NoteWindow に WPF RichTextBox 配置
  - TextBlock → RichTextBox に置き換え
  - 編集ON + 選択中: IsReadOnly=false, Focusable=true（テキスト編集可能）
  - 編集ON + 未選択: IsReadOnly=true, IsHitTestVisible=true（クリックで選択可能）
  - 編集OFF: Focusable=false, IsHitTestVisible=false（非干渉モード）
  - スクロールバー: 編集時Auto / 非編集時Hidden
  - WindowChrome.IsHitTestVisibleInChrome=True で WindowChrome との共存

[P4-2] 装飾ツールバー実装
  - ドラッグハンドル「⠿」(DockPanel.Dock=Left) + 装飾ボタン群(StackPanel)
  - 太字 B: EditingCommands.ToggleBold（Ctrl+B 対応）
  - 下線 U: EditingCommands.ToggleUnderline（Ctrl+U 対応）
  - 取り消し線 S: TextRange.ApplyPropertyValue(Inline.TextDecorationsProperty) で手動トグル
    ※ WPF EditingCommands に取り消し線がないため手動実装
    ※ 混在装飾の場合、他の装飾が失われる可能性あり（v0.2 許容）
  - 文字サイズ: ComboBox（8/10/12/14/16/18/20/24/28/36/48）
    - DropDownClosed でフォーカスを RichTextBox に戻す
  - 文字色: Button + Popup パレット（10色: 黒/白/赤/青/緑/オレンジ/紫/ピンク/水色/黄色）
    - TextColorIndicator（ボタン下部の色バー）で現在色を表示
  - SelectionChanged でツールバーボタン状態を自動同期（_isUpdatingToolbar フラグでフィードバック防止）
  - 全ボタン Focusable=False（RichTextBox のフォーカスを奪わない設計）

[P4-3] 適用ルール（FR-TEXT-4）
  - WPF の springloaded formatting で自動対応（追加コード不要）
  - 選択範囲あり → TextRange.ApplyPropertyValue で選択に適用
  - 選択範囲なし → カーソル以後のトグル状態保持（WPF 内蔵）

[P4-4] ツールチップ
  - 全ボタンに ToolTip 属性: "太字 (Ctrl+B)", "下線 (Ctrl+U)", "取り消し線", "文字サイズ", "文字色"
  - カラーパレット各色にも色名 ToolTip 付き

[P4-5] Undo/Redo
  - WPF RichTextBox 標準機能（Ctrl+Z / Ctrl+Y）で対応済み（追加コード不要）

[P4-6] クリップボード + フォント正規化
  - リッチ貼り付け優先 → プレーンフォールバック（WPF 標準動作）
  - DataObject.Pasting イベント + Dispatcher.BeginInvoke(DispatcherPriority.Background) で
    貼り付け完了後にドキュメント全体のフォントを付箋フォント（Model.Style.FontFamilyName）に正規化
  - PRD: 「フォントは付箋単位」「貼り付けで異なるフォントは付箋フォントに正規化」

[ビルド検証] ✅ エラー0、警告0、Lint クリーン

変更ファイル:
  - TopFusen/Views/NoteWindow.xaml（RichTextBox + 装飾ツールバー + 文字色パレットPopup）
  - TopFusen/Views/NoteWindow.xaml.cs（装飾ロジック + ツールバー状態同期 + フォント正規化）

==============================
Phase 5: 永続化（FR-PERSIST）— 2026-02-07
==============================

実装方針: 案B（PRD仕様準拠 — Atomic Write + デバウンス + 破損検知フォールバック）

[P5-1] PersistenceService 作成（Services/PersistenceService.cs）
  - JSON 読み書き: System.Text.Json（.NET 8 標準、追加パッケージ不要）
  - RTF 読み書き: byte[] でファイル直接 I/O
  - Atomic Write: tmp → File.Replace → .bak（1世代バックアップ）
  - 破損検知: JSON パース失敗 → .bak フォールバック → CorruptionRecovered フラグ
  - デバウンス: DispatcherTimer 3秒（UIスレッドで発火 — RichTextBox アクセスに必要）
  - FlushSave: 即時保存（終了 / SessionEnding 時用）
  - SaveRequested イベント: NoteManager.SaveAll() を呼び出す

[P5-2] notes.json 保存/読込
  - NotesData（全 NoteModel のメタデータリスト）を JSON シリアライズ
  - LoadJsonWithFallback<T> で破損時 .bak フォールバック付き読み込み

[P5-3] notes/{NoteId}.rtf 保存/読込
  - NoteWindow.GetRtfBytes(): TextRange.Save(stream, DataFormats.Rtf) → byte[]
  - NoteWindow.LoadRtfBytes(byte[]): TextRange.Load(stream, DataFormats.Rtf)
  - _isLoadingContent フラグで読み込み中の TextChanged 発火を抑制

[P5-4] settings.json 保存/読込
  - AppSettings の JSON シリアライズ（破損時 .bak フォールバック付き）

[P5-5] Atomic Write 実装
  - File.WriteAllText → tmp ファイル
  - File.Replace(tmp, main, bak) で旧 main → .bak に移動 + tmp → main に置換
  - 初回保存: File.Move(tmp, main)
  - File.Replace 失敗時: File.Copy フォールバック

[P5-6] 破損検知 + .bak フォールバック + ユーザー通知
  - メインファイルのパース失敗 → .bak を読み込み
  - CorruptionRecovered フラグ + RecoveryMessage を設定
  - App.xaml.cs: 起動後に Dispatcher.BeginInvoke で MessageBox 通知

[P5-7] デバウンス保存（3秒）
  - DispatcherTimer（UIスレッド発火）
  - ScheduleSave(): タイマーリセット → 最後の変更から3秒後に SaveAll
  - テキスト変更 / 位置変更 / サイズ変更 → NoteChanged イベント → ScheduleSave()

[P5-8] 終了時の強制フラッシュ
  - App.OnExit: _persistence.FlushSave() → 全ウィンドウ Close の前に保存
  - FlushSave: タイマー停止 → 即時 SaveRequested 発火

[P5-9] SessionEnding / Application.Exit フック
  - App.OnSessionEnding: _persistence.FlushSave()（ログオフ / シャットダウン時）
  - App.OnExit: _persistence.FlushSave() + _persistence.Dispose()

[P5-10] 起動時ロード → NoteManager.LoadAll()
  - settings.json 読み込み → AppSettings 復元
  - notes.json 読み込み → 各 NoteModel を RestoreNote() で復元
  - RestoreNote: NoteWindow 作成 → RTF 読み込み → 編集OFF → 変更追跡有効化
  - FR-BOOT-2: 起動直後は必ず編集OFF（非干渉モード）

[P5-11] 削除時のファイル掃除 + 孤立RTF自動削除
  - DeleteNote(): PersistenceService.DeleteRtf(noteId) + ScheduleSave()
  - LoadAll(): CleanupOrphanedRtfFiles() で notes.json に無い RTF を自動削除

NoteWindow 追加実装（Phase 5 連携）:
  - NoteChanged イベント: テキスト / 位置 / サイズ変更時に発火
  - _isTrackingChanges: 初期化完了後に有効化（初期化中の不要な保存を防止）
  - _isLoadingContent: RTF 読み込み中の TextChanged 抑制
  - SyncModelFromWindow(): ウィンドウの Left/Top/ActualWidth/ActualHeight を Model に同期
  - GetFirstLinePreview(): RichTextBox の先頭行テキスト取得（Z順一覧用）
  - EnableChangeTracking(): 初期化完了後に NoteManager が呼ぶ

NoteManager 追加実装（Phase 5 連携）:
  - コンストラクタ: PersistenceService を DI で受け取り、SaveRequested に SaveAll を登録
  - SaveAll(): 全モデル同期 → notes.json 保存 → 全RTF 保存 → settings.json 保存
  - LoadAll(): settings.json + notes.json 読み込み → RestoreNote() で復元 → 孤立RTF掃除
  - RestoreNote(): 保存された NoteModel から NoteWindow を復元
  - CreateNote / DuplicateNote / DeleteNote: 操作後に ScheduleSave()
  - DuplicateNote: RTF コンテンツもソースからコピー
  - WireUpNoteEvents: NoteChanged イベントを追加購読

App.xaml.cs 追加実装（Phase 5 連携）:
  - ConfigureServices: PersistenceService を DI に登録
  - OnStartup: LoadAll() → 破損復旧通知（MessageBox）
  - OnSessionEnding: FlushSave()
  - OnExit: FlushSave() → CloseAllWindows() → Dispose()

[ビルド検証] ✅ エラー0、警告0、Lint クリーン

新規ファイル:
  - TopFusen/Services/PersistenceService.cs（永続化サービス）

変更ファイル:
  - TopFusen/Views/NoteWindow.xaml.cs（RTF load/save + 変更追跡 + モデル同期）
  - TopFusen/Services/NoteManager.cs（SaveAll/LoadAll/RestoreNote + 永続化連携）
  - TopFusen/App.xaml.cs（DI登録 + LoadAll + FlushSave + 破損通知）

==============================
DJ-9: クリック透過を WM_NCHITTEST 単独制御に変更 — 2026-02-07
==============================

背景: Phase 5 実装後の実機テストで、WS_EX_TRANSPARENT + WS_EX_NOACTIVATE が
仮想デスクトップ追跡を破壊する問題が再発。DJ-8 のワークアラウンド
（生成時クリーン → Show() 後適用）では不十分だった。
「生成後に付けても」OS は VD 追跡を停止する。

[修正] SetClickThrough(): Win32 スタイル操作を完全除去
  - 旧: WS_EX_TRANSPARENT + WS_EX_NOACTIVATE の ON/OFF + WM_NCHITTEST（三重制御）
  - 新: _isClickThrough フラグ切替のみ → WM_NCHITTEST が唯一の制御手段
  - ウィンドウスタイルを一切変更しないので VD 追跡が常に維持される

[修正] OnSourceInitialized(): WS_EX_TRANSPARENT / WS_EX_NOACTIVATE の付与を除去
  - 念のため WS_EX_TOOLWINDOW / WS_EX_TRANSPARENT / WS_EX_NOACTIVATE の除去処理は残す
  - WM_NCHITTEST フックの登録はそのまま

[ビルド検証] ✅ エラー0、警告0

変更ファイル:
  - TopFusen/Views/NoteWindow.xaml.cs（SetClickThrough 簡素化 + OnSourceInitialized 修正）
  - TODO.md（DJ-9 設計判断追記）

==============================
Phase 8.0: VD 自前管理 技術スパイク（DJ-10）— 2026-02-07
==============================

背景: リサーチ AI による詳細調査の結果、以下が確定した：
  - WS_EX_TRANSPARENT なしでクロスプロセスクリック透過は不可能（背景不透明の場合）
  - WM_NCHITTEST → HTTRANSPARENT はクロスプロセスでは効かない（MS公式注記: 同一スレッド内）
  - EVENT_SYSTEM_DESKTOPSWITCH は仮想デスクトップ切替には使えない（Winlogon用）
  - 未公開COM通知はGUID変更リスク大（Win11 23H2で実際に発生）

DJ-10 方針: WS_EX_TRANSPARENT + DWMWA_CLOAK + DispatcherTimer ポーリング
  - クリック透過: WS_EX_TRANSPARENT + WS_EX_NOACTIVATE + WM_NCHITTEST の三重制御を復活
  - VD管理: OS のVD追跡に頼らず自前管理
  - 表示制御: DWMWA_CLOAK（DWM Cloak）でウィンドウの表示/非表示
  - 切替検知: DispatcherTimer 300ms ポーリング（Phase 8 でレジストリ監視に昇格予定）
  - 編集モード遷移: Cloak先行 → WS_EX_TRANSPARENT 付与（ちらつき対策）

[P8.0-1] NativeMethods 拡張
  - DwmSetWindowAttribute + DWMWA_CLOAK（P/Invoke）
  - SetWindowPos + HWND_TOPMOST + SWP_* 定数

[P8.0-2] VD Tracker Window 実装
  - WS_EX_TRANSPARENT なしの常駐HWND（1x1, 画面外, Opacity=0）
  - IsWindowOnCurrentVirtualDesktop による高速チェック（COM 1回）
  - Registry CurrentVirtualDesktop 読み出し（中速パス）
  - 短命ウィンドウ方式（低速パス/フォールバック）

[P8.0-3] DWMWA_CLOAK による Cloak/Uncloak
  - CloakWindow: DwmSetWindowAttribute(DWMWA_CLOAK, 1)
  - UncloakWindow: DwmSetWindowAttribute(DWMWA_CLOAK, 0) + SetWindowPos(TOPMOST) 再主張

[P8.0-4] DispatcherTimer ポーリング
  - 300ms 間隔で GetCurrentDesktopIdFast → 変化があれば DesktopChanged イベント発火
  - 最適化: 前回IDと同じならスキップ（高速パス: COM 1回）

[P8.0-5] WS_EX_TRANSPARENT 復活（DJ-9 撤回）
  - NoteWindow.SetClickThrough: Win32 スタイル操作を復元
  - OnSourceInitialized: 生成時はクリーン（DJ-8 維持）、Show() 後に適用

[P8.0-6] NoteManager VD 統合
  - CreateNote: 現在の DesktopId を付与
  - RestoreNote: DesktopId チェック → 非現在VD は Cloak
  - HandleDesktopSwitch: VD切替時に Cloak/Uncloak
  - SetEditMode: DJ-10 遷移シーケンス（Cloak先行/Uncloak後行）

[P8.0-7/8] App.xaml.cs 統合 + デバッグメニュー
  - VD Tracker 初期化 → デスクトップ監視開始
  - DesktopChanged → NoteManager.HandleDesktopSwitch
  - デバッグメニュー: Cloak/Uncloak テスト, 全付箋VD状態表示

[ビルド検証] ✅ エラー0、警告0

変更ファイル:
  - TopFusen/Interop/NativeMethods.cs（DwmSetWindowAttribute, SetWindowPos 追加）
  - TopFusen/Services/VirtualDesktopService.cs（Tracker + Cloak + ポーリング + Registry読出）
  - TopFusen/Views/NoteWindow.xaml.cs（DJ-10: WS_EX_TRANSPARENT 復活）
  - TopFusen/Services/NoteManager.cs（VD統合: DesktopId付与/Cloak/HandleDesktopSwitch）
  - TopFusen/App.xaml.cs（Tracker初期化 + 監視開始 + DesktopChanged + デバッグメニュー）
  - TODO.md（DJ-10 + Phase 8.0 追加）

--- 2026-02-07 Phase 8.0 Spike 検証完了 + バグ修正 ---

[Fix1] 起動順序バグ修正
  - 問題: App.xaml.cs で VirtualDesktopService 初期化が LoadAll() より後だった
  - 原因: RestoreNote 内の VD Cloak 処理が、サービス未初期化のため機能しなかった
  - 修正: Initialize() + InitializeTracker() を LoadAll() より前に移動
  - 結果: 起動直後から正しい VD に付箋が配置されるように

[Fix2] 編集ON中VD切替で1枚しか表示されないバグ修正
  - 問題: 編集ON時に WS_EX_TRANSPARENT を全付箋から除去していたため、
          OS のネイティブ VD 追跡が干渉
  - 修正: SetEditMode / HandleDesktopSwitch で、
          現在VDの付箋のみ WS_EX_TRANSPARENT 除去、
          他VDの付箋は WS_EX_TRANSPARENT 維持 + Cloak 維持
  - 結果: 編集ON中のVD切替でも正しく分離

[P8.0-VERIFY 実機検証結果] ★ 全項目パス
  1. DWMWA_CLOAK で付箋が隠れる/再表示 ... OK
  2. VD Tracker で現在デスクトップ ID 取得 ... OK
  3. クリック透過（クロスプロセス）復活 ... OK
  4. デスクトップ切替で正しい付箋のみ表示 ... OK
  5. Uncloak 後 Topmost 維持 ... OK
  6. 再起動後 DesktopId 復元 + 正しい VD 配置 ... OK
  7. 編集ON中の VD 切替でも正しく分離 ... OK（Fix2 後）
  8. 起動直後から正しい VD に配置 ... OK（Fix1 後）

Phase 8.0 スパイク: 技術的実現性を確認。DJ-10 方式の有効性が実証された。

--- 2026-02-07 Phase 8 本実装（案B: バランス）---

[P8-6] デスクトップ喪失フォールバック
  - VirtualDesktopService.IsDesktopAlive() — 単一 VD 存在チェック
  - VirtualDesktopService.FindOrphanedDesktopIds() — 一括孤立検出
  - NoteManager.RescueOrphanedNotes() — 起動時一括救済
  - HandleDesktopSwitch にリアルタイム救済追加（ただし動作せず → 後回し.md）
  - 実機検証: 起動時救済 OK / VD 1つ環境 OK

[P8-7] ポーリング間隔最適化
  - 300ms → 500ms（CPU負荷軽減、体感遅延なし確認済み）

[P8-8] スパイクコード整理
  - コメント・ログ: Phase 8.0 → Phase 8 統一
  - デバッグメニュー: ラベル簡潔化

[後回し] VD 削除時のリアルタイム救済が動作しない
  - 再起動で復旧可能（実害限定的）
  - 詳細: 引き継ぎ資料置き場/後回し.md

Phase 8 完了。次は Phase 6（見た目・スタイル）。
